# -*- coding: utf-8 -*-
"""MATH4143_Assign2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/138dO-1_jaZsKiQkxFtlE_-wh0iArGZxP
"""

#Assignment 2
#Nitesh Bansal
#219106814

#Al the constants and imports are defined here
import math
import numpy as np
import matplotlib.pyplot as plt
from scipy.stats import norm
#from Black_Scholes import BS_call, BS_put
S0 = 100
r = 0.05
T = 0.25
K = 100  # Strike price for butterfly option
M = 10000  # Number of time steps
N = 100  # Number of space steps
S_max = 200  # Maximum stock price
def sigma(s):
  return 0.15 + 0.15 * np.tanh((s - 105) / 10)**2

#Part 1
#Tweaking the explicit BS model

# Define the correct butterfly option payoff function
def butterfly_payoff(s, K):
    if s <= 95:
        return 0
    elif 95 < s <= 105:
        return (s - 95) / 10 * 10  # Linear growth from 0 to 10
    elif 105 < s <= 115:
        return (115 - s) / 10 * 10  # Linear drop from 10 to 0
    else:
        return 0

def solve_BS_explicit_butterfly(S0,T,r,K,M,N,S_max):

    delta_t=T/M
    delta_s=S_max/N

    #**********************************************************
    f=np.zeros((N+1,M+1))
    #**********************************************************

    # initial condition
    for i in range(N+1):
        si=i*delta_s
        f[i,0]=butterfly_payoff(si, K)
    #**********************************************************
    # doing the iteration in time
    for j in range(M):
        for i in range(1,N):
            si=i*delta_s;
            sigma_val = sigma(si)
            f[i,j+1]=f[i-1,j]*(-r*si*delta_t/(2*delta_s)+0.5*sigma_val**2*si**2*delta_t/delta_s**2)\
                +f[i,j]*(1-sigma_val**2*si**2*delta_t/delta_s**2-r*delta_t)\
                +f[i+1,j]*(r*si*delta_t/(2*delta_s)+0.5*sigma_val**2*si**2*delta_t/delta_s**2)
        # set the boundary conditions as zero as specified
        f[0,j+1]=0
        f[N,j+1]=0
    #**********************************************************
    # return the result (as a row vector) -- the price of a call option at maturity
    # for the initial stockp price S0 -- do linear interpolation in s variable
    j = math.floor(S0 / delta_s)
    h = S0 / delta_s - j
    f_result = f[j, M] * (1 - h) + f[j+1, M] * h

    return f_result

def solve_BS_CN_single_price_butterfly(S0, T, r, K, M, N, S_max):
    delta_t = T / M  # Time step
    delta_s = S_max / N  # Space step
    S0_index = math.floor(S0 / delta_s)
    delta_s = S0 / S0_index

    f_old = np.zeros((N-1, 1))
    f_new = np.zeros((N-1, 1))

    # Initial condition (butterfly option payoff)
    for i in range(N-1):
        si = (i+1) * delta_s
        f_old[i] = butterfly_payoff(si, K)

    # Compute the matrix C
    C = np.zeros((N-1, N-1))
    for i in range(N-1):
        for j in range(N-1):
            si = (i+1) * delta_s
            sigma_val = sigma(si)  # Use the local volatility function
            if i > 0:
                C[i, i-1] = r * si * delta_t / (2 * delta_s) - 0.5 * sigma_val**2 * si**2 * delta_t / delta_s**2
            C[i, i] = sigma_val**2 * si**2 * delta_t / delta_s**2 + r * delta_t
            if i < N-2:
                C[i, i+1] = -r * si * delta_t / (2 * delta_s) - 0.5 * sigma_val**2 * si**2 * delta_t / delta_s**2

    # Doing the iteration in time
    G = np.zeros((N-1, 1))
    D = 2 * np.identity(N-1) - C
    C_inv = np.linalg.inv(2 * np.identity(N-1) + C)

    for j in range(M):
        s = (N-1) * delta_s
        sigma_val = sigma(s)
        G[N-2] = (-r * s * delta_t / (2 * delta_s) - 0.5 * sigma_val**2 * s**2 * delta_t / delta_s**2) * (s - K * np.exp(-r * (j+1) * delta_t))
        f_new = np.matmul(C_inv, np.matmul(D, f_old) - G)
        f_old = f_new

    # Return the interpolated result at S0
    return f_old[S0_index-1]

# Solve using explicit finite difference method
f_approx_explicit = solve_BS_explicit_butterfly(S0, T, r, K, M, N, S_max)
print(f"The approximate butterfly explicit option price for S0={S0}, T={T} is {f_approx_explicit}")
# Solve using Crank-Nicolson method for butterfly option price
f_approx = solve_BS_CN_single_price_butterfly(S0, T, r, K, M, N, S_max)
print(f"The approximate butterfly CN option price for S0={S0}, T={T} is {f_approx[0]}")

#new S0 and T
S0 = 103
T = 0.5

# Solve using explicit finite difference method
f_approx_explicit = solve_BS_explicit_butterfly(S0, T, r, K, M, N, S_max)
print(f"The approximate butterfly explicit option price for S0={S0}, T={T} is {f_approx_explicit}")
# Solve using Crank-Nicolson method for butterfly option price
f_approx = solve_BS_CN_single_price_butterfly(S0, T, r, K, M, N, S_max)
print(f"The approximate butterfly CN option price for S0={S0}, T={T} is {f_approx[0]}")

#new S0 and T
S0 = 98
T = 2

# Solve using explicit finite difference method
f_approx_explicit = solve_BS_explicit_butterfly(S0, T, r, K, M, N, S_max)
print(f"The approximate butterfly explicit option price for S0={S0}, T={T} is {f_approx_explicit}")
# Solve using Crank-Nicolson method for butterfly option price
f_approx = solve_BS_CN_single_price_butterfly(S0, T, r, K, M, N, S_max)
print(f"The approximate butterfly CN option price for S0={S0}, T={T} is {f_approx[0]}")